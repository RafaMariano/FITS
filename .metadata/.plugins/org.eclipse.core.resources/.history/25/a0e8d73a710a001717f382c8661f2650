package br.inpe.log;

import java.io.IOException;
import java.nio.file.DirectoryNotEmptyException;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;

import br.inpe.model.FileSystem;
import br.inpe.model.Image;
import br.inpe.model.ImagesCollection;
import nom.tam.fits.Fits;
import nom.tam.fits.FitsException;

public class Verify {
	private Path pathCorrupted;
	private Path log;

	public Verify(String pathCorrupted, String log) throws IOException {
		this.pathCorrupted = Paths.get(pathCorrupted);
		this.log = Paths.get(log);
		if (Files.notExists(this.log, LinkOption.NOFOLLOW_LINKS))
			Files.createFile(this.log);
	}

	public ImagesCollection verify() throws IOException {

		List<String> lines = FileSystem.getInstance().getLog();
		int size = lines.size() - 1;

		if (size > -1) {

			FileSystemResult result = FileSystemResult.convert(lines.get(size));

			if (result != null) {

				switch (result) {
				case CREATE_SUCCESSFUL:
					String imageColl = getVerifyCreate(lines.get(0), lines.get(1));
					
					if (imageColl == null)
						return null;
					
					
					System.out.println("a");
					break;
				case MOVE_SUCCESSFUL:
					System.out.println("b");
					break;
				case DELETE_SUCCESSFUL:
					System.out.println("c");
					break;
				}
			} else {
				// deleteLog();
			}
		}
		return null;
	}

	private String fileExistInPathPrincipal(String imagePath, String destinationPath) throws FitsException, IOException {
	
		Fits fits = new Fits(imagePath);
		long size = fits.getHDU(0).getHeader().getLongValue("SIZE");

		if (Files.size(Paths.get(imagePath)) == size) {

			ArrayList<String> paths = getDestinationPath(new StringBuilder(destinationPath),
					new StringBuilder(imagePath));
			FileSystem.getInstance().createDir(imagePath, paths.get(1), paths.get(0));
			FileSystem.getInstance().moveFile(imagePath, destinationPath);
			FileSystem.getInstance().deletePath(imagePath.substring(0, imagePath.lastIndexOf("/")), paths.get(0));
			fits.close();
			return destinationPath;

		} else {

			moveToCorruptedDirectory(imagePath);
			fits.close();
			return null;
		}
	}

	private void moveToCorruptedDirectory(String imagePath) throws DirectoryNotEmptyException, IOException {
		StringBuilder st = new StringBuilder(this.pathCorrupted.toString());
		st.append(imagePath.substring(imagePath.lastIndexOf("/") - 1));
		FileSystem.getInstance().moveFile(imagePath, st.toString());
	}

	private String getVerifyCreate(String imagePath, String destinationPath) {

		try {

			if (Files.exists(Paths.get(imagePath), LinkOption.NOFOLLOW_LINKS)) {

				String path = fileExistInPathPrincipal(imagePath, destinationPath);
				if (path == null)
					return path;
				Image image = new Image(path);
			
			} else if (Files.exists(Paths.get(destinationPath), LinkOption.NOFOLLOW_LINKS)) {
				
			}
		} catch (IOException io) {

		} catch (FitsException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return "";
	}

	public ArrayList<String> getDestinationPath(StringBuilder destinatioPath, StringBuilder principalPath) {

		int lastIndexOfDestination = destinatioPath.lastIndexOf("/");
		int lastIndexOfPrincipal = principalPath.lastIndexOf("/");

		if (destinatioPath.substring(lastIndexOfDestination)
				.equals(principalPath.substring(lastIndexOfPrincipal)) == false) {

			ArrayList<String> paths = new ArrayList<>();
			paths.add(principalPath.toString());
			paths.add(destinatioPath.toString());
			return paths;
		}

		destinatioPath.setLength(lastIndexOfDestination);
		principalPath.setLength(lastIndexOfPrincipal);

		return getDestinationPath(destinatioPath, principalPath);
	}

}
